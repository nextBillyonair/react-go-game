{"version":3,"sources":["game/Square.js","game/Logic.js","game/Board.js","App.js","serviceWorker.js","index.js"],"names":["Square","props","className","onClick","value","crypto","require","stones","black","white","union","setA","setB","_union","Set","elem","add","Logic","squares","createHash","update","toString","digest","stone","empty_positions","reduce","a","e","i","concat","rand_pos","Math","floor","random","length","this","place","evaluate","get_adjacent","n_i","chain_data","get_chain","has_liberty","chain","stack","visited","node","pop","has","adj_pos","push","index_to_coord","x","y","neighbors","coord_to_index","accounted_for","belonging","disputed","neutral","empty","data","get_area","color","pieces","size","st","Board","logic","empty_board","Array","fill","state","blackIsNext","score","hash_codes","hash_board","current_hash","passes","autoplay","game_over","handleClick","bind","handleReset","handlePass","handleRandom","handleAutoplay","isIllegalMove","determineWinner","event","setState","target","checked","autoplay_timer","setInterval","clearInterval","winner","alert","hash_code","squares_pos","show_alert","is_illegal","random_turn","slice","tries","key","status","score_status","map","object","renderSquare","board_rows","type","onChange","React","Component","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.fcb8624a.chunk.js","sourcesContent":["import React from 'react';\nimport './Square.css';\n\n// const stones = {\n//   black: \"●\",\n//   white: \"○\",\n// };\n\nfunction Square (props) {\n  // given value, change class name for dynamic highlighting\n  // let square_class;\n\n  // switch (props.value) {\n  //   case stones.black:\n  //     square_class = \"square-black\";\n  //     break;\n  //   case stones.white:\n  //     square_class = \"square-white\";\n  //     break;\n  //   default:\n  //     square_class = \"square-empty\";\n  //     break;\n  // }\n\n\n  return (\n    <button\n      className={'square'}\n      onClick={props.onClick}>\n      {props.value}\n    </button>\n  );\n}\n\nexport default Square;\n","const crypto = require('crypto');\n\n\nconst stones = {\n  black: \"●\",\n  white: \"○\",\n};\n\n// Class to Handle All Game Logic, Called By Board\nclass Logic {\n\n\n  hash_board(squares) {\n    return crypto.createHash('sha1').update(squares.toString()).digest('hex');\n  }\n\n  random_turn(squares, stone) {\n    let empty_positions = squares.reduce(\n      (a, e, i) => (e === null) ? a.concat(i) : a, []\n    );\n\n    const rand_pos = empty_positions[Math.floor(Math.random() * empty_positions.length)];\n\n    return [this.place(squares, rand_pos, stone), rand_pos];\n  }\n\n\n  place(squares, i, stone) {\n    // place stone\n    squares[i] = stone;\n\n    // evaluate other stones\n    squares = this.evaluate(squares, i);\n\n    return squares;\n  }\n\n\n  evaluate(squares, i) {\n    for (const n_i of this.get_adjacent(i).concat([i])) {\n      const chain_data = this.get_chain(squares, n_i);\n      if (!chain_data.has_liberty) {\n        // delete\n        for (const c_i of chain_data.chain) {\n          squares[c_i] = null;\n        }\n      }\n    }\n    return squares;\n  }\n\n\n  get_chain(squares, i) {\n    const stone = squares[i];\n\n    if (stone === null) {\n      return {has_liberty:true, chain: new Set()};\n    }\n\n    let chain_data = {has_liberty:false, chain: new Set([i])};\n\n    let stack = [i];\n    let visited = new Set(); //add(el) & has('el')\n\n    while (stack.length > 0) {\n\n      const node = stack.pop();\n\n      if (!visited.has(node)) {\n        visited.add(node);\n\n        for (const adj_pos of this.get_adjacent(node)){\n          if (squares[adj_pos] === null) {\n            chain_data.has_liberty = true;\n          } else if (squares[adj_pos] === stone) {\n            stack.push(adj_pos);\n            chain_data.chain.add(adj_pos);\n          }\n        }\n      }\n    }\n    return chain_data;\n  }\n\n\n  get_adjacent(i) {\n    const [x, y] = this.index_to_coord(i);\n    let neighbors = [];\n\n    if (x > 0) {\n      neighbors.push(this.coord_to_index(x - 1, y));\n    }\n    if (x < 18) {\n      neighbors.push(this.coord_to_index(x + 1, y));\n    }\n    if (y > 0) {\n      neighbors.push(this.coord_to_index(x, y - 1));\n    }\n    if (y < 18) {\n      neighbors.push(this.coord_to_index(x, y + 1));\n    }\n\n    return neighbors;\n  }\n\n  index_to_coord(i) {\n    return [Math.floor(i / 19), i % 19];\n  }\n\n  coord_to_index(x, y){\n    return x * 19 + y;\n  }\n\n\n\n  score(squares) {\n    let empty_positions = squares.reduce(\n      (a, e, i) => (e === null) ? a.concat(i) : a, []\n    );\n\n    let accounted_for = new Set();\n    let belonging = {\n      black: new Set(), white: new Set(), disputed: new Set(), neutral: new Set()\n    };\n\n    for (const empty of empty_positions) {\n      if (!accounted_for.has(empty)) {\n        const data = this.get_area(squares, empty);\n        accounted_for = union(accounted_for, data.chain);  //UNION\n        if (data.neighbors.length === 2) {\n          belonging.disputed = union(belonging.disputed, data.chain);\n        } else if (data.neighbors.length === 1) {\n          belonging[data.neighbors[0]] = union(belonging[data.neighbors[0]], data.chain)\n        } else {\n          belonging.neutral = union(belonging.neutral, data.chain)\n        }\n      }\n    }\n\n    for (const color of ['black', 'white']) {\n      const pieces = squares.reduce(\n        (a, e, i) => (e === stones[color]) ? a.concat(i) : a, []\n      );\n      belonging[color] = union(belonging[color], pieces);\n    }\n\n    // we can actually color\n    return {\n      black: belonging.black.size,\n      white: belonging.white.size,\n      disputed: belonging.disputed.size,\n      neutral: belonging.neutral.size,\n    }\n  }\n\n\n  get_area(squares, i) {\n    const stone = squares[i];\n    let chain = new Set([i]);\n    let stack = [i];\n    let visited = new Set(); //add(el) & has('el')\n    let disputed = new Set();\n\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (!visited.has(node)) {\n        visited.add(node);\n        for (const adj_pos of this.get_adjacent(node)) {\n          if (squares[adj_pos] !== null) {\n            const st = (squares[adj_pos] === stones.black) ? 'black' : 'white';\n            disputed.add(st);\n          } else if (squares[adj_pos] === stone)  {\n            stack.push(adj_pos);\n            chain.add(adj_pos)\n          }\n        }\n      }\n    }\n    return {neighbors: [...disputed], chain: chain}\n  }\n\n}\n\n// aux union function\nfunction union(setA, setB) {\n    let _union = new Set(setA)\n    for (let elem of setB) {\n        _union.add(elem)\n    }\n    return _union\n}\n\n\n\n\nexport default Logic;\n","import React from 'react';\nimport Square from './Square';\nimport './Board.css';\nimport Logic from './Logic';\n\nconst stones = {\n  black: \"●\",\n  white: \"○\",\n};\n\n\n\n// Renders Board Items\nclass Board extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.logic = new Logic();\n\n    const empty_board = Array(361).fill(null);\n\n    this.state = {\n      squares: empty_board,\n      blackIsNext: true,\n      score: this.logic.score(empty_board),\n      hash_codes: [this.logic.hash_board(empty_board)],\n      current_hash: this.logic.hash_board(empty_board),\n      passes: 0,\n      autoplay: false,\n      game_over: false\n    };\n\n    this.handleClick = this.handleClick.bind(this);\n    this.handleReset = this.handleReset.bind(this);\n    this.handlePass = this.handlePass.bind(this);\n    this.handleRandom = this.handleRandom.bind(this);\n    this.handleAutoplay = this.handleAutoplay.bind(this);\n    this.isIllegalMove = this.isIllegalMove.bind(this);\n    this.determineWinner = this.determineWinner.bind(this);\n  }\n\n  handleAutoplay(event) {\n    if (this.state.game_over) {\n      return;\n    }\n\n    this.setState({\n      autoplay: event.target.checked\n    });\n\n    if (event.target.checked) {\n      let autoplay_timer = setInterval(\n        () => {\n          if (!this.state.autoplay) {\n            clearInterval(autoplay_timer);\n          } else {\n            this.handleRandom(null);\n          }\n        }, 100 // adjust timer to personal pref, or have slider?\n      );\n    }\n  }\n\n\n  handleReset() {\n    const empty_board = Array(361).fill(null);\n\n    this.setState((state) => ({\n      squares: empty_board,\n      blackIsNext: true,\n      score: this.logic.score(empty_board),\n      hash_codes: [this.logic.hash_board(empty_board)],\n      current_hash: this.logic.hash_board(empty_board),\n      passes: 0,\n      autoplay: false,\n      game_over: false\n    }));\n  }\n\n  determineWinner() {\n    let winner = `Game Over!!! ${stones.black} has won the game!!!`; // default\n    if (this.state.score.black < this.state.score.white) {\n      winner = `Game Over!!! ${stones.white} has won the game!!!`;\n    } else if (this.state.score.black === this.state.score.white) {\n      winner = `Game Over? Seems to be a tie...`\n    }\n    return winner;\n  }\n\n  handlePass(event, autoplay=false) {\n    if (this.state.game_over) {\n      this.setState({autoplay:false});\n      return; //easy way to avoid new moves\n    }\n\n    let game_over = false;\n    if (this.state.passes + 1 === 2) {\n      alert(this.determineWinner());\n      game_over = true;\n    } else if (this.state.passes + 1 > 2){\n      game_over = true;\n    }\n\n    this.setState((state) => ({\n      blackIsNext: !state.blackIsNext,\n      passes: state.passes + 1,\n      autoplay: ((!state.game_over || game_over) ? autoplay : false),\n      game_over: (state.game_over ? true : game_over)\n    }));\n    // maybe recompute hash, and the end game condition is if hash appears 2 before.\n  }\n\n  // refactor?\n  isIllegalMove(hash_code, squares_pos, show_alert=true) {\n    // return false; // uncomment if you want to void these rules\n    let is_illegal = false;\n    if (hash_code === this.state.hash_codes[this.state.hash_codes.length-2]){\n      if (show_alert) {\n        this.setState({autoplay: false});\n        alert('Warning! Ko: Cannot return to previous position!');\n      }\n      is_illegal = true;\n    } else if (squares_pos === null) {\n      if (show_alert) {\n        this.setState({autoplay: false});\n        alert('Warning! Suicide: Cannot commit suicide!');\n      }\n      is_illegal = true;\n    } else if (this.state.game_over) {\n      this.setState({autoplay: false});\n      is_illegal = true; //easy way to avoid new moves\n    }\n    return is_illegal;\n  }\n\n  handleRandom(event) {\n    if (this.state.game_over) {\n      this.setState({autoplay:false});\n      return; //easy way to avoid new moves\n    }\n\n    // take random turn, in fact, call handleClick on random empty index.\n    const stone = this.state.blackIsNext ? stones.black : stones.white;\n\n    let [squares, rand_pos] = this.logic.random_turn(this.state.squares.slice(), stone);\n    let hash_code = this.logic.hash_board(squares);\n\n    // Question: Should we do while loop until valid? To avoid illegal moves?\n    // Break on count, then just pass\n    // if (this.isIllegalMove(hash_code, squares[rand_pos])) {\n    //   return;\n    // }\n\n    let tries = 5; // tech gives us 6 tries\n    while (this.isIllegalMove(hash_code, squares[rand_pos], false) && tries > 0) {\n      [squares, rand_pos] = this.logic.random_turn(this.state.squares.slice(), stone);\n      hash_code = this.logic.hash_board(squares);\n      tries = tries - 1;\n    }\n\n    if (this.isIllegalMove(hash_code, squares[rand_pos], false)) {\n      this.handlePass(null, true);\n      return;\n    }\n\n    const score = this.logic.score(squares);\n\n    this.setState((state) => ({\n      squares: squares,\n      blackIsNext: !state.blackIsNext,\n      score: score,\n      current_hash: hash_code,\n      hash_codes: state.hash_codes.concat([hash_code]),\n      passes: 0,\n      autoplay: (event === null)\n    }));\n\n  }\n\n\n  handleClick(i) {\n    let squares = this.state.squares.slice();\n    if (squares[i] || this.state.game_over) {\n      this.setState({autoplay:false});\n      return;\n    }\n\n    // UPDATE with game logic!!!!\n    // squares[i] = this.state.blackIsNext ? stones.Black : stones.White;\n    const stone = this.state.blackIsNext ? stones.black : stones.white;\n    squares = this.logic.place(squares, i, stone);\n    const score = this.logic.score(squares);\n    const hash_code = this.logic.hash_board(squares);\n\n    if (this.isIllegalMove(hash_code, squares[i])) {\n      return;\n    }\n\n    this.setState((state) => ({\n      squares: squares,\n      blackIsNext: !state.blackIsNext,\n      score: score,\n      current_hash: hash_code,\n      hash_codes: state.hash_codes.concat([hash_code]),\n      passes: 0,\n      autoplay: false\n    }));\n\n  }\n\n  renderSquare(i) {\n    return (\n      <Square\n        key={i}\n        value={this.state.squares[i]}\n        onClick={() => this.handleClick(i)} //pre-pop with index\n      />\n    );\n  }\n\n\n  render() {\n    let status = 'Current player: ' + (this.state.blackIsNext ? stones.black : stones.white);\n    if (this.state.game_over) {\n      status = this.determineWinner();\n    }\n    const score_status = `Score: ${stones.black}: ${this.state.score.black}, ${stones.white}: ${this.state.score.white}, Contested: ${this.state.score.disputed}`;\n    const squares = this.state.squares.map((object, i) => this.renderSquare(i));\n\n    const board_rows = Array(19).fill(null).map(\n      (elem, i) => (\n        <div className=\"board-row\" key={i}>\n          {squares.slice(i * 19, i * 19 + 19)}\n        </div>\n      )\n    );\n\n    return (\n      <div>\n        <div className=\"status\">{status}</div>\n        {board_rows}\n        <div className=\"status\">{score_status}</div>\n        <div className=\"status\">\n          <button className=\"status-button\" onClick={this.handleReset}>Reset</button>\n          <button className=\"status-button\" onClick={this.handlePass}>Pass</button>\n          <button className=\"status-button\" onClick={this.handleRandom}>Random</button>\n        </div>\n        <div className=\"status\">\n          Autoplay\n          <label className=\"switch\">\n            <input type=\"checkbox\" checked={this.state.autoplay} onChange={this.handleAutoplay}/>\n            <span className=\"slider round\"></span>\n          </label>\n        </div>\n      </div>\n    );\n\n    // Add AutoPlay Button!!!!!!!!\n  }\n\n\n}\n\n\nexport default Board;\n","import React from 'react';\nimport './App.css';\nimport Board from './game/Board'\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <Board />\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}